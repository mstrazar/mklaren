"""

The algorithms based on centered aligmnent proposed in

C. Cortes, M. Mohri, and A. Rostamizadeh, "Algorithms for Learning Kernels Based on Centered Alignment," J. Mach. Learn. Res., vol. 13, pp. 795-828, Mar. 2012.

Given :math:`p` kernel matrices :math:`\mathbf{K}_1, \mathbf{K}_2, ..., \mathbf{K}_p`, centered kernel alignment learns a linear combination of kernels resulting in a combined kernel matrix.

.. math::
    \mathbf{K}_{c\mu} = \sum_{q=1}^p \mu_q \mathbf{K}_{cq}

where :math:`\mathbf{K}_{cq}` is the centered kernel matrix.

.. math::
    \mathbf{K}_{cq} = (\mathbf{I} - \dfrac{\mathbf{11}^T}{n})\mathbf{K}_q (\mathbf{I} - \dfrac{\mathbf{11}^T}{n})


The following methods perform a constrained optimization over :math:`\mathbf{\mu} = (\mu_1, \mu_2, ... \mu_p)` maximizing the centered alignment:

.. math::
    A = \dfrac{<\mathbf{K}_{c\mu}, \mathbf{y}\mathbf{y}^T>_F} {n <\mathbf{K}_{c\mu}, \mathbf{K}_{c\mu}>_F}

where :math:`\mathbf{y}\mathbf{y}^T` is the ideal kernel based on target vector :math:`\mathbf{y}` and :math:`<\cdot, \cdot>_F` is a matrix inner product.
"""
from ..kernel.kernel import center_kernel
from ..util.la import fro_prod, fro_prod_low_rank
from numpy import zeros, sqrt
from numpy import ndarray


class Align:

    """
    :ivar Kappa: (``numpy.ndarray``) Combined kernel matrix.

    :ivar mu: (``numpy.ndarray``) Kernel weights.

    """

    def __init__(self, d=2):
        """
        :param d: degree.
        """
        self.d = 2

    def fit(self, Ks, y, holdout=None):
        """Learn weights for kernel matrices or Kinterfaces.

        :param Ks: (``list``) of (``numpy.ndarray``) or of (``Kinterface``) to be aligned.

        :param y: (``numpy.ndarray``) Class labels :math:`y_i \in {-1, 1}` or regression targets.

        :param holdout: (``list``) List of indices to exlude from alignment.
        """
        q = self.d
        m = len(y)
        mu = zeros((len(Ks), ))
        y = y.reshape((m, 1))

        # Generalization to Kinterfaces
        Ks = [K[:, :] for K in Ks]

        # Filter out hold out values
        if not isinstance(holdout, type(None)):
            holdin = sorted(list(set(range(m)) - set(holdout)))
            y = y[holdin]
            Ksa = map(lambda k: k[holdin, :][:, holdin], Ks)
            en = enumerate(Ksa)
            Ky = y.dot(y.T)
        else:
            Ksa = Ks
            en = enumerate(Ksa)
            Ky = y.dot(y.T)

        for ki, K in en:
            mu[ki] = fro_prod(center_kernel(K), Ky)**(1.0/(q - 1))
        mu = mu / mu.sum()
        Kappa = sum([mu_i * k_i for mu_i, k_i in zip(mu, Ks)])

        self.Kappa   = Kappa
        self.mu      = mu
        self.trained = True


    def __call__(self, i, j):
        """
        Access portions of the combined kernel matrix at indices i, j.

        :param i: (``int``) or (``numpy.ndarray``) Index/indices of data points(s).

        :param j: (``int``) or (``numpy.ndarray``) Index/indices of data points(s).

        :return:  (``numpy.ndarray``) Value of the kernel matrix for i, j.
        """
        assert self.trained
        if isinstance(i, ndarray):
            i = i.astype(int).ravel()
        if isinstance(j, ndarray):
            j = j.astype(int).ravel()
        if isinstance(i, int) and isinstance(j, int):
            return self.Kappa[i, j]
        else:
            return self.Kappa[i, :][:, j]

    def __getitem__(self, item):
        """
        Access portions of the kernel matrix generated by ``kernel``.

        :param item: (``tuple``) pair of: indices or list of indices or (``numpy.ndarray``) or (``slice``) to address portions of the kernel matrix.

        :return:  (``numpy.ndarray``) Value of the kernel matrix for item.
        """
        assert self.trained
        return self.Kappa[item]



class AlignLowRank(Align):
    """
    Use the align method using low-rank kernels.
    Useful for computing alignment of low-rank representations.
    """

    def fit(self, Gs, y, holdout=None):
        """Learn weights for low-rank representations of kernel matrices.

        :param Gs: (``list``) of (``numpy.ndarray``) to be aligned.

        :param y: (``numpy.ndarray``) Class labels :math:`y_i \in {-1, 1}`.

        :param holdout: (``list``) List of indices to exlude from alignment.
        """
        q   = self.d
        m   = len(y)
        mu  = zeros((len(Gs), ))
        y   = y.reshape((m, 1))

        # Filter out hold out values
        if not isinstance(holdout, type(None)):
            holdin = sorted(list(set(range(m)) - set(holdout)))
            y      = y[holdin]
            Gsa    = map(lambda g: g[holdin, :], Gs)
            en     = enumerate(Gsa)
        else:
            Gsa    = Gs
            en     = enumerate(Gsa)

        for gi, G in en:
            Gc     = G - G.mean(axis=0)
            mu[gi] = fro_prod_low_rank(Gc, y)**(1.0/(q - 1))

        mu       = mu / mu.sum()

        self.Gs      = Gs
        self.mu      = mu
        self.trained = True


    def __call__(self, i, j):
        """
        Access portions of the combined kernel matrix at indices i, j.

        :param i: (``int``) or (``numpy.ndarray``) Index/indices of data points(s).

        :param j: (``int``) or (``numpy.ndarray``) Index/indices of data points(s).

        :return:  (``numpy.ndarray``) Value of the kernel matrix for i, j.
        """
        assert self.trained
        if isinstance(i, ndarray):
            i = i.astype(int).ravel()
        if isinstance(j, ndarray):
            j = j.astype(int).ravel()

        return sum([m * (G[i, :].dot(G[j, :].T))
                    for m, G in zip(self.mu, self.Gs)])


    def __getitem__(self, item):
        """
        Access portions of the kernel matrix generated by ``kernel``.

        :param item: (``tuple``) pair of: indices or list of indices or (``numpy.ndarray``) or (``slice``) to address portions of the kernel matrix.

        :return:  (``numpy.ndarray``) Value of the kernel matrix for item.
        """
        assert self.trained
        return sum([m * (G[item[0]].dot(G[item[1]].T))
                    for m, G in zip(self.mu, self.Gs)])

